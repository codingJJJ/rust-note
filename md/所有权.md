```rust
fn main () {
  // 所有权
  /*
   * 栈内存stack vs 堆内存 heap
   * Stack按值的接收顺序来存储，按相反的顺序将它们移除(先进后出, LIFO)
   *    添加数据叫压栈
   *    移除数据叫出栈
   * 所有存储在栈上的数据必须拥有已知的固定大小
   *    编译时大小未知的数据或运行时大小可能发生变化的数据必须放在heap上
   * Heap内存组织性差一些
   *    当你把所有数据放入Heap时，你会请求一定数量的空间
   *    操作系统在Heap里找到一块足够大的空间，把他标记为再用，并返回一个指针，也就是这哥空间的地址
   *    这个过程叫做在Heap上进行分配，有时仅仅称"分配"
   * 把值压到stack上不叫分配
   * 因为指针是已知固定大小的，可以把指针放在stack上
   *    但如果想要实际数据，必须使用指针来定位
   * 把数据压到stack上要去heap上分配快的多
   *    因为操作系统不需要寻找用来存储新数据的空间，那个值永远都在stack的顶端
   * 在heap上分配空间需要做更多的工作
   *    操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配
   * 
   * 访问stack与heap数据
   *    访问heap中的数据要比stack上访问stack中的数据慢，因为需要通过指针才能找到heap中的数据
   *        对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快
   * 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些,例如把数据放在stack上
   * 相反，如果数据之间的距离比较远，那么处理速度就会慢一些,例如把数据放在heap上
   *    例外，在heap上分配大量的空间也是需要时间的
   * 
   * 函数调用
   *    当代码调用函数时，值被传入到函数(也包括指向heap的指针)。函数本地的变量被压到stack上。当函数结束后，这些值会从stack上弹出
   * 所有权存在的原因
   *    所有权解决的问题
   *        跟踪代码那些部分正在使用heap的那些数据
   *        最小化heap上的重复数据量
   *        清理heap上未使用数据以避免空间不足
   *        管理heap数据是所有权存在的原因，这有助于解释它为什么会这样做
   */

  /*
   * 所有权规则
   *    每个值都有一个变量，这个变量是该值的所有者
   *    每个值同时只能拥有一个所有者
   *    当所有者超出作用域时，该值将被删除
   *
   *    变量作用域(scope): 程序中一个项目的有效范围
   *    fn fnTest () {
   *       // s不可用
   *       let s = "hello"; // s可用
   *       // 可对s做相关操作
   *     } // s作用域到此结束，s不可用
   *    
   */
  
  /*
   * 用String类型来演示相关所有权
   * String数据类型
   * String比那些基础数据类型标量数据更为复杂，在heap上分配，能够存储在编译时未知数量的文本
   * 字符串字面值: 程序里手写的那些字符串值是不可变的
   */

  let mut s: String = String::from("hello");
  s.push_str(", word");
  println!("{}", s);

  /*
   * 为什么String类型的值可以修改，而字符串字面值不能修改？
   *    因为他们处理内存的方式不同
   * 内存和分配
   *    字符串字面值在编译时就知道它的内容，其文本内容直接被硬编码到终于的可执行文件里
   *        速度快，高效。因为其不可变性。
   *    String类型为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容
   *        这就意味着操作系统必须在运行时请求内存
   *            即通过String::from这步来实现的
   *        当用完String之后，需要使用某种方式将内存返回给操作系统
   *            这步在有用GC的语言中，GC会跟踪并清理不再使用的内存
   *            没有GC就需要我们自己去识别内存何时不再使用，并调用代码将他们返回
   *                如果忘了内存就会被浪费，如果提前做了变量就会非法，如果做了2次就会出现bug，必须一次分配一次释放
   *    Rust采用了不同的方式，对于某个值来说，当拥有它的变量走出作用域范围时，内存会自动的交还给操作系统
   *    Drop函数
   *        当变量走出作用域时，Rust会调用Drop函数，清理内存
   */

  // 变量的数据交互方式
    // 移动(move):多个变量可以与同一个数据使用一种独特的方式来交互,移动可以保证被误操作进行二次释放
    let x = 5;
    let y = x;
    println!("{}{}", y, x); // 整数是已知且固定大小的简单值，所以x跟y都被压到了stack中

    let x = String::from("hello");
    let y = x;  // 因为x是放在heap中的，在赋值时，x会失效，x的值会移动到y，将所有权交给y
    println!("{}", y);
    // println!("{}", x); // 报错，因为此时的x已经失效了，错误提示为借用了移动之后的值
    // 隐含的设计原则,Rust不会自动创建数据的深拷贝，就运行时性能而言，任何赋值的操作都是廉价的

    // 克隆(clone):如果真想对heap上面的String数据进行深度拷贝，而不仅仅是stack上的数据，可以使用clone方法
    let x = String::from("6");
    let y = x.clone();
    println!("{}{}", x, y);
    // 复制: 针对stack上的数据，我们可以叫做复制
    // Copy trait,可以用于像整数这样完全存放在stack上面的类型
    // 如果一个类型实现了copy这个trait,那么旧的变量在赋值后依然可用
    // 如果一个类型或者该类型的一部分实现了Drop copy,那么rust不允许让它再去实现Copy trait了
    
    /*
     * 一些拥有Copy trait的类型
     *    所有整数类型
     *    所有浮点类型
     *    Tuple(元组)，如果其所有字段都是Copy的，其本身也可以copy
     *    布尔类型
     *    字符类型
     *    任何简单标量的组合类型都是可以Copy的
     *    任何需要分配内存或者某种资源的都不是Copy的
     *    
     */
}
```