```rust
fn main () {
  /*
   * 如何让函数使用某个值但不获得所有权
   * Rust有个特性叫做'引用Reference' &符号
   * &表示引用某些值，而不取得其所有权
   */
  let s1 = String::from("312");
  let s2 = fn_reference(&s1); // &s1表示它引用了s1，但并不取得s1的所有权，当s1走出fn_reference作用域时，s1不会被销毁

  println!("{}", s1); // 因为s1一直没有交出所有权，所以s1能够被打印
  println!("{}", s2);

  fn fn_reference (s: &String) -> usize { // &String表示引用
    s.len()
  }
  /*
   * 我们把引用作为函数参数这个行为叫做借用
   * 借用的数据是不可变的
   * 如果加上mut关键字,可变引用在相同的作用域内只能存在一个，这样可以在编译时，防止数据竞争
   * 不可以同时拥有一个可变引用和一个不可变引用，但是多个不可变的引用是可以的
   */

  let mut s = String::from("123321");
  {
    let s1 = &mut s; // 这里的s1只在当前{}作用域中有效
  };

  let s2 = &mut s; // 因为s1跟s2不在同一个作用域中，所以再次使用借用是合法的

  println!("{}{}", s1, s2);

  /*
   * 悬空引用 Dangling References
   * 悬空引用：一个指针引用了内存中的某个地址，而这块内存已经被释放或已经分配给其他人使用了
   * Rust中，编译器可以保证引用永远都不是悬空引用
   */

  let r = danger();

  println!("rrr{}", r);

  fn danger () -> &String { // 这里会报错，缺少一个声明周期的说明符
    let s = String::from("hello");
    &s  // 这里返回了一个s的引用，但是s在出作用域，已经被drop函数清理，所以返回s的引用会错误提示，rust不允许悬空指针的发生
  }

  /*
   * 引用规则 
   * 只能拥有一个可变引用
   * 或任意数量不可变引用
   * 引用必须一直有效
   */
}
```