```rust
fn main() {
    // #rust 数据类型#

    /*
     * 标量与复合类型
     * 基于使用值 rust编译器通常能推断处它的具体类型
     * 但如果可能的类型比较多，例如把String转为整数parse方法，
     * 就必须添加类型标注，否则会报错
     * 必须显示声明guess类型
     * let guess: i32 = "42".parse().expect("not a number");
     */

    // #rust主要有4个主要类型
    /*
     * 整数类型
     *    u32: 无符号整数类型，占据32位空间
     *    i32: 有符号整数类型(整数类型默认类型)
     *    isize,
     *    usize:由程序运行时的计算机架构决定
     *         使用它们主要场景是对某种集合进行索引操作
     *    整数的字面值:
     *        Decimal(十进制): 92_222
     *        Hex(十六进制): 0xff
     *        Octal(八进制): 0o77
     *        Decimal(二进制): 0b1010
     *        Byte(字节): b'A'
     *        注：出了byte类型，所有整数类型都允许使用类型后缀
     *            例：57u8
     * 浮点类型
     *    f32,32位单精度
     *    f64,64位双精度(浮点类默认类型)
     * 布尔类型
     *    true
     *    false
     * 字符类型
     *    char:描述语言中最基础的单个字符，占4个字节
     *         字符字面值使用单引号
     */

    // #rust 复合类型#
    /*
     * Tuple(元组)
     *    在小括号里,用值将逗号隔开
     *    例：let mytup:(i32, char, bool) = (1, '1', true);
     *        println!("{}{}{}", mytup.0, mytup.1, mytup.2);
     *    获取Tuple的元素值
     *        可以使用模式匹配来解构(destructure)一个Tuple来获取元素值
     *    例：  let (x, y, z) = mytup;
     *          println!("{}{}{}", x, y, z);
     * 数组
     *    数组存放于栈内存中
     *    如果想让数据放在栈内存中，或者想保证固有数量的元素，这时使用数组更有优势。
     *    数组没有Vector灵活，Vector由标准库提供。Vector长度灵活
     *    获取数组元素值 
     *      let a: [i32;5] = [1,2,3,4,5];
     *      println!("{}", a[2])
     *    如果数组索引超过了数组范围，那么
     *      编译会通过
     *      运行时，会报错(runtime时会panic)
     */
    
    

}

```